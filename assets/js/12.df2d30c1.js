(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{215:function(e,r,t){"use strict";t.r(r);var a=t(0),l=Object(a.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"docker-的使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#docker-的使用"}},[e._v("#")]),e._v(" docker 的使用")]),e._v(" "),t("h3",{attrs:{id:"_1、docker-的常用命令介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、docker-的常用命令介绍"}},[e._v("#")]),e._v(" 1、docker 的常用命令介绍")]),e._v(" "),t("p",[t("code",[e._v("详见docker常用命令.md")])]),e._v(" "),t("ol",[t("li",[e._v("查看Docker 版本")])]),e._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  docker --version \n  docker-compose --version\n  docker-machine --version\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("运行一个 Nginx 服务器：")])]),e._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  $ docker run -d -p 80:80 --name webserver nginx\n")])])]),t("ul",[t("li",[e._v('服务运行后，可以访问 http://localhost，如果看到了 "Welcome to nginx!"，就说明 Docker for Mac 安装成功了。')]),e._v(" "),t("li",[e._v("要停止 Nginx 服务器并删除执行下面的命令：")])]),e._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  1. docker stop webserver\n  2. docker rm webserver\n")])])]),t("p",[t("a",{attrs:{href:"https://docs.docker.com/engine/reference/commandline/docker/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://docs.docker.com/engine/reference/commandline/docker/"),t("OutboundLink")],1)]),e._v(" "),t("ol",{attrs:{start:"3"}},[t("li",[e._v("docker pull Docker 镜像仓库获取镜像\n"),t("a",{attrs:{href:"https://hub.docker.com/explore/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Docker Hub"),t("OutboundLink")],1),e._v("上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。\n其命令格式为：")])]),e._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  * docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n")])])]),t("p",[e._v("docker pull --help 查看命令帮助信息          docker pull [OPTIONS] NAME[:TAG|@DIGEST]\n* Docker 镜像仓库地址：地址的格式一般是 <域名/IP>[:端口号]。默认地址是 Docker Hub。\n* 仓库名：如之前所说，这里的仓库名是两段式名称，即 <用户名>/<软件名>。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。\n比如：")]),e._v(" "),t("div",{staticClass:"language-shell extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  $ docker pull ubuntu:16.04\n  16.04: Pulling from library/ubuntu\n  7b8b6451c85f: Pull complete \n  ab4d1096d9ba: Pull complete \n  e6797d1788ac: Pull complete \n  e25c5c290bde: Pull complete \n  Digest: sha256:e547ecaba7d078800c358082088e6cc710c3affd1b975601792ec701c80cdd39\n  Status: Downloaded newer image for ubuntu:16.04\n")])])]),t("p",[e._v("上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 ubuntu:16.04，因此将会获取官方镜像 library/ubuntu 仓库中标签为 16.04 的镜像\n4. docker run 启动一个容器\n如：\n启动镜像里面的 bash 进行交互式操作：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("  docker run -it --rm \\ubuntu:16.04 \\bash\n")])])]),t("ul",[t("li",[e._v("-it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。")]),e._v(" "),t("li",[e._v("--rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。")]),e._v(" "),t("li",[e._v("ubuntu:16.04：这是指用 ubuntu:16.04 镜像为基础来启动容器。")]),e._v(" "),t("li",[e._v("bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。")])]),e._v(" "),t("p",[e._v("进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 16.04.5 LTS 系统。")]),e._v(" "),t("p",[e._v("最后可以通过 exit 退出了这个容器。")]),e._v(" "),t("ol",{attrs:{start:"5"}},[t("li",[e._v("docker image ls (docker iamges)列出镜像")])]),e._v(" "),t("ul",[t("li",[e._v("列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。")]),e._v(" "),t("li",[e._v("一个镜像可以对应多个标签，但 "),t("code",[e._v("镜像 ID")]),e._v(" 则是镜像的唯一标识。")])]),e._v(" "),t("ol",{attrs:{start:"6"}},[t("li",[e._v("docker system df 查看镜像、容器、数据卷所占用的空间")])]),e._v(" "),t("ul",[t("li",[e._v("由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。")])]),e._v(" "),t("ol",{attrs:{start:"7"}},[t("li",[e._v("docker image ls -f dangling=true 显示虚悬镜像(dangling image) ，由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 的镜像。")])]),e._v(" "),t("ul",[t("li",[t("code",[e._v("docker image ls -a")]),e._v(" 显示包括中间层镜像在内的所有镜像\n这时可能会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。")]),e._v(" "),t("li",[t("code",[e._v("docker image ls ubuntu")]),e._v(" 根据仓库名列出镜像")]),e._v(" "),t("li",[t("code",[e._v("docker image ls ubuntu:16.04")]),e._v(" 列出特定的某个镜像，也就是说指定仓库名和标签")]),e._v(" "),t("li",[t("code",[e._v("docker image ls -f since=mongo:3.2")]),e._v(" 使用过滤器来列出虚悬镜像\ndocker image ls 还支持强大的过滤器参数 --filter，或者简写 -f。如之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 mongo:3.2 之后建立的镜像")]),e._v(" "),t("li",[t("code",[e._v("docker image ls -q")]),e._v(" 所有的虚悬镜像的 ID 列出来")]),e._v(" "),t("li",[t("code",[e._v("docker image ls --digests")]),e._v(" 显示镜像摘要")]),e._v(" "),t("li",[t("code",[e._v("docker image ls --format")]),e._v(" .ID: .Repository 当对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 [Go 的模板语法]<(https://gohugo.io/templates/introduction/)>")]),e._v(" "),t("li",[e._v("或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：\n"),t("code",[e._v("docker image ls --format")]),e._v(' "table .ID\\t .Repository \\t .Tag"')])]),e._v(" "),t("ol",{attrs:{start:"8"}},[t("li",[t("code",[e._v("docker image prune")]),e._v(" 删除虚悬镜像 一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的")]),e._v(" "),t("li",[t("code",[e._v("docker image rm")]),e._v(" [选项] <镜像1> [<镜像2> ...] 删除本地镜像\n用 ID、镜像名、摘要删除镜像")])])])}),[],!1,null,null,null);r.default=l.exports}}]);